# JMM

### 1.什么是JMM

JMM 是Java内存模型( Java Memory Model），简称JMM。它本身只是一个抽象的概念，并不真实存在，它描述的是一种规则或规范，是和多线程相关的一组规范。通过这组规范，定义了程序中对各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

### 2. JMM的结构

计算机在执行程序的时候，每条指令都是在cpu里完成的，而资源的获取是从主存中获得的，对比cpu的执行速率来说，io操作从主存获取资源太慢，大幅度的降低了效率。因此，cpu和主存直接有了个高速缓存区，cpu和主存不直接交互，而是通过把数据写到缓存再从缓存把数据写到主存，这种方式来交互，好处其一是，操作缓存的速率是比主存快的，其二是，缓存里有数据，防止多次的重复io。

![](https://static001.geekbang.org/infoq/08/083068485ad1e93dd6f6ef85ee47e21f.png)

关于工作内存：

在JVM中，java虚拟机栈是我们主要的工作环境，而java栈每个线程私有的，方法区，堆这些才是线程公有的。

​ 但线程对变量的操作（读取赋值等）必须在自己的工作内存中进行。首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后，再将变量写回到主内存。由于不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存中的变量副本，因此，不同的线程之间无法直接访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。
ava 内存模型（Java Memory Model, JMM）规定了八种操作，这些操作定义了线程如何与主内存交互。这些操作是为了规范线程在读取和写入共享变量时的行为，确保多线程程序的正确性和可见性。

### 3. JMM 的八种操作

1. **lock（锁定）**
2. **unlock（解锁）**
3. **read（读取）**
4. **load（加载）**
5. **use（使用）**
6. **assign（赋值）**
7. **store（存储）**
8. **write（写入）**

#### 1. lock（锁定）

- **作用**：把一个变量标记为线程独占状态。
- **示例**：进入一个 `synchronized` 块时，线程获取锁定。

#### 2. unlock（解锁）

- **作用**：把一个变量从线程独占状态释放，释放后的变量可以被其他线程锁定。
- **示例**：退出一个 `synchronized` 块时，线程释放锁定。

#### 3. read（读取）

- **作用**：把一个变量从主内存读取到工作内存，读取后的变量副本会存储在工作内存中。
- **示例**：线程从主内存读取共享变量 `x` 到工作内存。

#### 4. load（加载）

- **作用**：把工作内存中某个变量的副本加载到工作内存中的一个变量副本中。
- **示例**：从 read 操作读取到的变量副本加载到工作内存的某个变量副本中。

#### 5. use（使用）

- **作用**：把工作内存中某个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用某个变量的值的字节码指令时，会执行这项操作。
- **示例**：线程执行方法中使用变量 `x` 的值。

#### 6. assign（赋值）

- **作用**：把一个从执行引擎接收到的值赋值给工作内存中的变量副本，每当虚拟机遇到一个给变量赋值的字节码指令时，会执行这项操作。
- **示例**：线程给变量 `x` 赋值。

#### 7. store（存储）

- **作用**：把工作内存中的一个变量的值传递到主内存中，以便后续的 write 操作把变量值写入到主内存的变量中。
- **示例**：线程准备把变量 `x` 的值从工作内存写回主内存。

#### 8. write（写入）

- **作用**：把从 store 操作得到的变量的值写入到主内存的变量中。
- **示例**：线程把变量 `x` 的值写入主内存。

### 4. JMM 的主要概念

#### 1. 主内存（Main Memory）

主内存是所有线程共享的内存区域，包含所有的共享变量。主内存是一个全局共享空间，所有线程的工作内存都会从这里读取数据或者将数据写入这里。

#### 2. 工作内存（Working Memory）

工作内存是每个线程独立的内存区域，存储了该线程需要使用的变量的副本。线程对变量的操作（读取和写入）都在工作内存中进行，之后再同步到主内存。每个线程都有自己的工作内存，所以工作内存中的数据对于其他线程是不可见的。

#### 3. 内存屏障（Memory Barrier）

内存屏障是一种硬件或软件机制，用于保证内存操作的顺序性和可见性。内存屏障确保在屏障包裹的操作读写都是正确无误的。

进入同步块

当一个线程进入同步块时，会插入一个内存屏障，确保进入同步块之前的所有读写操作都已完成。

退出同步块

当一个线程退出同步块时，会插入一个内存屏障，确保退出同步块之后的所有读写操作不能重排序到同步块内部。

#### 4. Happens-Before 关系

Happens-Before 关系是 JMM 中定义的一种规则，用于描述程序执行顺序与内存操作之间的关系。Happens-Before 关系提供了一个偏序关系，用来判断两个操作是否存在顺序依赖，从而保证多线程程序的正确性。常见的 Happens-Before 规则包括：

- **程序顺序规则**：一个线程内，按照代码顺序执行。
- **监视器锁规则**：一个线程对锁的解锁操作 Happens-Before 另一个线程对同一锁的加锁操作。
- **volatile 变量规则**：对一个 `volatile` 变量的写操作 Happens-Before 读操作。
- **线程启动规则**：一个线程的启动操作 Happens-Before 该线程的所有操作。
- **线程终止规则**：一个线程的所有操作 Happens-Before 其他线程检测到该线程终止。

### 5.三大特性

#### 1. 可见性

JMM 通过 `volatile` 关键字和内存屏障来保证可见性。当一个线程修改 `volatile` 变量时，修改后的值会立即被刷新到主内存，并且其他线程读取这个变量时会直接从主内存中读取最新的值。

#### 2. 有序性

JMM 通过 Happens-Before 规则和内存屏障来保证操作的有序性。编译器和处理器可能会对指令进行重排序，但在多线程环境中，Happens-Before 规则确保指令的执行顺序不会破坏线程间的正确性。

#### 3. 原子性

原子性是指某个操作是不可分割的，即使在多线程环境下也不会被中断。JMM 通过同步块和锁机制来保证操作的原子性。

### JMM怎么用的

JMM 主要用于以下几个方面：

### 1. **多线程共享变量的可见性**

JMM 定义了线程如何通过共享内存进行通信。当一个线程对共享变量进行写操作后，其他线程能否看到这个修改，这由 JMM 决定。JMM 通过 `volatile` 关键字和 `synchronized` 关键字来保证变量的可见性：

- **`volatile` 关键字**：确保对变量的读写操作直接从主内存中进行，而不是从线程的工作内存中。通过禁止指令重排序和利用内存屏障，`volatile` 变量的修改对其他线程立即可见。
- **`synchronized` 关键字**：确保在进入和退出同步块时，线程对共享变量的读写操作能够正确地刷新到主内存中，保证可见性。

### 2. **线程间的操作顺序（Happens-Before 关系）**

JMM 定义了多个 Happens-Before 规则，用于保证线程间操作的顺序性。这些规则帮助开发者理解和预测多线程程序的执行顺序，避免线程间的可见性和一致性问题：

- **程序顺序规则**：一个线程内的操作按照代码顺序执行。
- **监视器锁规则**：一个线程对锁的解锁操作 Happens-Before 另一个线程对同一锁的加锁操作。
- **volatile 变量规则**：对 `volatile` 变量的写操作 Happens-Before 该变量的读操作。
- **线程启动和终止规则**：一个线程的启动操作 Happens-Before 该线程的所有操作，该线程的所有操作 Happens-Before 终止检测。
- **中断规则**：对线程的中断操作 Happens-Before 被中断线程检测到中断事件。

### 3. **防止指令重排序**

为了优化程序性能，编译器和处理器可能会对指令进行重排序。这在单线程程序中通常没有问题，但在多线程程序中可能导致不可预见的错误。JMM 通过以下机制来防止不安全的指令重排序：

- **内存屏障（Memory Barrier）**：插入内存屏障指令，确保特定的内存操作在内存屏障前或后完成。
- **Happens-Before 规则**：定义了操作之间的顺序关系，防止编译器和处理器对这些操作进行重排序。

### 4. **同步机制**

JMM 为 Java 提供了一套同步机制，确保多线程程序中的内存操作是可见且有序的：

- **synchronized 块和方法**：使用监视器锁（Monitor Lock）确保代码块内的操作是互斥的，同时保证对共享变量的操作可见性。
- **Lock 接口和其他并发工具类**：Java 提供的 `java.util.concurrent` 包中的锁机制（如 `ReentrantLock`）和其他并发工具类（如 `CountDownLatch`、`Semaphore` 等）依赖于 JMM 以确保正确的内存可见性和操作顺序。
